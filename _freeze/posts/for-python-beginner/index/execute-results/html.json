{
  "hash": "33d1cdffcfc6e96717b58079c7294f02",
  "result": {
    "markdown": "---\ntitle: Python Tips\nauthor: Gleko Ma\ndate: 2022/5/3\ncategories:\n  - code\nimage: image.jpg\n---\n\nA few tips for beginner.\n\n## 变量和对象\n\n### Python中变量的实质为指针\n\n在Python中给变量赋值很简单，只需把变量名和要赋予的值用等号连接起来即可，例如：\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\n# 把 4赋给x\nx = 4\n```\n:::\n\n\n这个赋值操作非常自然且直接，但它的本质可能跟你想的不太一样。\n在很多编程语言里（例如C、R），变量都可以认为是一个盛装数据的容器。例如在C中，你可以这样写：\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nint x = 4;\n```\n:::\n\n\n这行代码的全部意思就是：你让计算机定义了一小块儿内存，名叫``x``，然后把值4放了进去。但是，在Python中，``x = 4``的意思并不是这样的。Python中的变量是一个指向内存的指针而非这块儿内存本身。下面看一个简单的例子：\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nx = [1, 2, 3]\ny = x\nprint(y)\nx.append(4) # 给列表x添加一个 4\nprint(y)\n```\n\n::: {.cell-output-stdout}\n```\n[1, 2, 3]\n[1, 2, 3, 4]\n```\n:::\n:::\n\n\n我们只改变了``x``的值，``y``的值却也发生了相同的变化！下面对这个例子做一些延伸：\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nx = 'Hello'\nprint(y)\n```\n\n::: {.cell-output-stdout}\n```\n[1, 2, 3, 4]\n```\n:::\n:::\n\n\n可以肯定，``x``的值发生了变化。而``y``的值却没有变。\n\nPython中的变量其实只是徒有虚名，它只是一个名字而已，当你调用它时，例如：调用``x``时，计算机就去访问``x``这个变量指向的那块儿内存，一看这个内存里头的值是[1, 2, 3]，于是计算机就返回给你[1, 2, 3]。然后你又执行``y = x``，计算机又把``y``指向``x``，一看``x``不是块儿内存，它只是一个指针，于是顺藤摸瓜，``y``就直接指向了原来的那块儿内存[1, 2, 3]。所以说这两个赋值操作其实只创建了一块儿内存，``x``和``y``共用它。当你执行``x.append(4)``时，计算机直接对所指向的那块儿内存进行操作，于是那块儿内存的值变为了[1, 2, 3, 4]，所以此时你再输出``y``的话，它所指向的值现在是[1, 2, 3, 4]，于是输出给你就是[1, 2, 3, 4]，而不是原来的[1, 2, 3]了。\n\n所以说，一句话，Python中``x = 4``不要读作“把4赋予``x``”，而应该读成“``x``指向4”。\n\n还记得上面的c代码吗？它是这样写的：\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nint x = 4;\n```\n:::\n\n\n你肯定发现它多了一个``int``，而且不加这个``int``它就会运行出错，所犯错误为：没有指定变量类型。但我们在Python中就可以直接这样写：``x = 4``，千万不要以为Python中的变量没有类型，其实只是``x``这个变量名没有类型，实际``x``所指向的内存4是有类型（int类型）的。你可以这样写：\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nx = 4 # x是一个整数\nx = 'hello' # 现在x是一个字符串\nx = [1, 2, 3] # 现在x是一个列表\n```\n:::\n\n\n在c中，一旦你声明了``int x = 4``，那它就是整型数字，你后面就不能再给它赋成字符串，会报错。而Python中``x``是一个指针，你可以让它指向任何类型的数据（当``x``指向其他值时，如果原来的值没有被什么变量指向，那这块儿应该就被自动清理了，我认为大概是这样，没有查过）。所以常说Python是动态语言，意思其实就是它的变量类型可变，而c就不是动态的。\n\n当我们说Python中的“变量”时，我们指的是什么？例如：\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nx = 4\n```\n:::\n\n\n直接说结论，我认为，``x``是变量、是变量名、是指针。而当我们说变量``x``时，我们通常想要表达的是变量名``x``与它所指向的那块儿内存（值为4）这个捆绑体。但它的本质其实只是一副躯壳，一个名字而已。\n\n### 一切皆为对象\n\nPython是一个面向对象语言，Python中一切都是对象。\n\n你也许正摸不着头脑：什么是面向对象？怎么到处都听说这个概念，但却从来没人站出来把它解释清楚？现在让我们试图把它弄明白。\n\n上一节我们讲了“变量为指针“的概念，即变量名自身不携带任何类型（int、str、float等）信息。现在看几个例子：\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nx = 4\ntype(x)\n```\n\n::: {.cell-output-display execution_count=6}\n```\nint\n```\n:::\n:::\n\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nx = 'hello'\ntype(x)\n```\n\n::: {.cell-output-display execution_count=7}\n```\nstr\n```\n:::\n:::\n\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nx = 3.14159\ntype(x)\n```\n\n::: {.cell-output-display execution_count=8}\n```\nfloat\n```\n:::\n:::\n\n\n如果你已经弄明白了上节的内容，那你一定想到这里``type(x)``的结果其实输出的是``x``指向的那块儿内存的类型。一句话，Python中有类型，但类型不是绑定在变量名上，而是绑定在**对象**本身上的。即这里type的作用对象为那块儿内存本身。\n\n在Python中，**对象**其实指的是一个携带信息的实体，这个实体携带三种信息：**值**、**属性**和**方法**。值，顾名思义，你执行``x = 4``，那这个对象（那块儿内存）的值就为4，然后执行你：\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nx\n```\n\n::: {.cell-output-display execution_count=9}\n```\n3.14159\n```\n:::\n:::\n\n\n很自然的，它输出了4。所以，访问（使用）对象的值很简单，直接输入即可。\n\n访问（使用）对象的属性和方法则需要用“.”来实现，你一定见过，例如：\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nL = [1, 2, 3]\nL.append(100)\nprint(L)\n```\n\n::: {.cell-output-stdout}\n```\n[1, 2, 3, 100]\n```\n:::\n:::\n\n\n这里我们调用了这个对象的所具有的方法``append``，不同的对象具有不同的方法，具体这个对象具有什么属性什么方法，完全依赖于这个对象是什么类型（你可能疑问，对象不就三种信息吗？怎么又跑出来一个类型？其实你可以把类型归到**值**里面，值的类型嘛。我个人是这么理解的）。下面给一个访问（使用）对象属性的例子：\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nx = 4.5\nprint(x.real, \"+\", x.imag, 'i')\n```\n\n::: {.cell-output-stdout}\n```\n4.5 + 0.0 i\n```\n:::\n:::\n\n\n这里我们访问（使用）了数字型（int、float都属于数字型大类）对象的``real``（实部）和``imag``（虚部）属性，并将其以复数格式打印了出来。\n\n访问（使用）属性和方法的方式有什么不同呢？它们间的区别就在于，属性没有括号，直接写成``x.real``，而方法有括号，例如``L.append(100)``。下面再看一个例子：\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nx = 4.5\nx.is_integer()\n```\n\n::: {.cell-output-display execution_count=12}\n```\nFalse\n```\n:::\n:::\n\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nx = 4.0\nx.is_integer()\n```\n\n::: {.cell-output-display execution_count=13}\n```\nTrue\n```\n:::\n:::\n\n\n猜一猜上面调用了对象的属性还是方法？答案当然是方法，因为有括号！（浮点数有一个方法名叫``is_integer``，这个方法的作用是判断这个浮点数是不是一个整数（跟整型不是一个意思！），而上面的代码就是它的实际演示。）\n\n当我们说Python中一切皆为对象，请注意，我们的指的是一切，Right，一切。所以一个对象的属性和方法本身，也是一个对象。例如：\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nx = 4.5\ntype(x.is_integer)\n```\n\n::: {.cell-output-display execution_count=14}\n```\nbuiltin_function_or_method\n```\n:::\n:::\n\n\n(发现了吗？这里``x.is_integer``没有括号。为什么？想象一下，如果输入``type(x.is_integer())``会输出什么？[^1])\n\nPython一切皆为对象的设计带来了一些非常方便的特性，以后慢慢体会。\n\n[^1]: 会输出<class 'bool'>\n\n## 参考资料\n\n[1]A Whirlwind Tour of Python by Jake VanderPlas (O’Reilly). Copyright 2016 O’Reilly Media, Inc., 978-1-491-96465-1\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}
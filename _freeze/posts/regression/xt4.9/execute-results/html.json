{
  "hash": "6ec8052096ff318922e1af3b3f06430a",
  "result": {
    "markdown": "---\ntitle: 习题4.9\nfig-height: 3\nfig-width: 5\ndescription: 违背基本假设的情况\n---\n\n> **下表是用电高峰每小时用电量$y$与每月总用电量$x$的数据。**\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(haven)\ndata = read_sav(\"data/xt4.9.sav\")\nhead(data)\n```\n\n::: {.cell-output-stdout}\n```\n# A tibble: 6 × 3\n   序号     x     y\n  <dbl> <dbl> <dbl>\n1     1   679  0.79\n2     2   292  0.44\n3     3  1012  0.56\n4     4   493  0.79\n5     5   582  2.7 \n6     6  1156  3.64\n```\n:::\n:::\n\n#### 1. 用普通最小二乘法建立$y$与$x$的回归方程，并画出残差散点图\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel0 = lm(y ~ x, data)\nmodel0\n```\n\n::: {.cell-output-stdout}\n```\n\nCall:\nlm(formula = y ~ x, data = data)\n\nCoefficients:\n(Intercept)            x  \n  -0.831304     0.003683  \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nggplot(model0, aes(x=x, y=.resid)) + \n    geom_point() + \n    geom_hline(yintercept = 0) + \n    labs(y=\"Residuals\")\n```\n\n::: {.cell-output-display}\n![](xt4.9_files/figure-html/unnamed-chunk-3-1.png){width=480}\n:::\n:::\n\n#### 2. 诊断该问题是否存在异方差性\n\n*答：是。*\n\n::: {.cell}\n\n```{.r .cell-code}\n# 等级相关系数法（Spearman检验）\n# 因为数据中有相同数字，其会产生结（tie）\n# 导致触发警告（Warning），但能够计算出结果\n# 为避免警告，可进行修正，如添加随机扰动等\n# 设置参数exact=FALSE即可\ncor.test(data$x, data$y, \n         method=\"spearman\", \n         exact=FALSE)\n```\n\n::: {.cell-output-stdout}\n```\n\n\tSpearman's rank correlation rho\n\ndata:  data$x and data$y\nS = 5501.1, p-value = 7.005e-12\nalternative hypothesis: true rho is not equal to 0\nsample estimates:\n      rho \n0.7782191 \n```\n:::\n:::\n\n\n#### 3. 如果存在异方差性，用幂指数型的权函数建立加权最小二乘回归方程\n\n::: {.cell}\n\n```{.r .cell-code}\n# 编写寻找最优权函数\n# 特定于幂指型权函数的一元回归\nbest_weight_1d = function(data, left=-2, right=2){\n    the_seq = seq(left, right, 0.5)\n    vec = rep(NA, length(the_seq))\n    j = 1\n    for (m in the_seq){\n        model1 = lm(y ~ x,\n                    weights=1/x^m,\n                    data=data)\n        vec[j] = logLik(model1) # logLik函数计算模型的对数似然值\n        j = j + 1\n    }\n    best_local = which.max(vec)\n    if(best_local != left & best_local != right){\n        cat(\"幂指数最优取值为:\", the_seq[best_local])\n    }else if(best_local == left){\n        cat(\"最优值在边界达到，请扩充范围（left）\")\n    }else{\n        cat(\"最优值在边界达到，请扩充范围（right）\")\n    }\n}\nbest_weight_1d(data)\n```\n\n::: {.cell-output-stdout}\n```\n幂指数最优取值为: 1.5\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# 令m=1.5\nmodel1 = lm(y ~ x, weights=1/x^1.5, data=data)\nmodel1\n```\n\n::: {.cell-output-stdout}\n```\n\nCall:\nlm(formula = y ~ x, data = data, weights = 1/x^1.5)\n\nCoefficients:\n(Intercept)            x  \n  -0.683463     0.003557  \n```\n:::\n:::\n\n#### 4. 用方差稳定变换$y'=\\sqrt{y}$消除异方差性\n\n::: {.cell}\n\n```{.r .cell-code}\ndata$y = sqrt(data$y)\nmodel2 = lm(y ~ x, data)\nmodel2\n```\n\n::: {.cell-output-stdout}\n```\n\nCall:\nlm(formula = y ~ x, data = data)\n\nCoefficients:\n(Intercept)            x  \n  0.5822259    0.0009529  \n```\n:::\n:::",
    "supporting": [
      "xt4.9_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": [],
    "engineDependencies": {},
    "preserve": {},
    "postProcess": null
  }
}